/* eslint-disable @typescript-eslint/no-unused-vars */
import { useState, useEffect, useRef } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useUserStore } from '../store/userStore';
import { usePeopleStore } from '../store/peopleStore';
import { useChartTab } from '../store/chartStore';
import { useNatalChart } from './useNatalChart';
import { useStatusToast } from './useStatusToast';
import { usePeopleAPI } from './usePeopleAPI';
import { Person } from '../types/people';
import { trackChartGeneration } from '../lib/analytics'; // Use Google Analytics
import { BRAND } from '../config/brand';

export const useChartPage = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { user, isProfileComplete, isLoading: isUserLoading, loadProfile } = useUserStore();
  const { setSelectedPerson: setGlobalSelectedPerson, selectedPerson: globalSelectedPerson } = usePeopleStore();
  const { activeTab, setActiveTab } = useChartTab();
  const { defaultPerson, selectedPerson: peopleSelectedPerson, loadPeople } = usePeopleAPI();
  
  // Local state
  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null);
  const [sharedChartLoaded, setSharedChartLoaded] = useState(false);
  
  // Use people system's selected person, or global selected person, or local state, or default person
  const activeSelectedPerson = peopleSelectedPerson || globalSelectedPerson || selectedPerson || defaultPerson;
  
  // Chart management
  const {
    generateChart,
    isGenerating,
    cachedChart,
    shareChart,
    getUserCharts,
    hasExistingChart,
    isLoadingCache,
  } = useNatalChart(activeSelectedPerson);
  
  // Status toast management
  const { toast: statusToast, showSuccess, showError, hideStatus } = useStatusToast();
  
  // Create refs for stable function references
  const generateChartRef = useRef(generateChart);
  const getUserChartsRef = useRef(getUserCharts);
  
  // Update refs when functions change
  useEffect(() => {
    generateChartRef.current = generateChart;
    getUserChartsRef.current = getUserCharts;
  }, [generateChart, getUserCharts]);
  
  // Load user profile when component mounts
  useEffect(() => {
    if (!user && !isUserLoading) {
      loadProfile();
    }
  }, [user, isUserLoading, loadProfile]);
  
  // Load people when user is available
  useEffect(() => {
    if (user?.id) {
      loadPeople();
    }
  }, [user?.id, loadPeople]);
  
  // Check for existing charts and auto-generate if needed (with delay to prevent race conditions)
  useEffect(() => {
    if (isLoadingCache || cachedChart || isGenerating || !user) {
      return;
    }
    
    // Add delay to let the cache loading complete and prevent race conditions with form submissions
    const timeoutId = setTimeout(() => {
      const loadOrGenerateChart = async () => {
        // Double-check these conditions after the delay
        if (isGenerating || cachedChart) return;
        
        try {
          const existingCharts = await getUserChartsRef.current();
          if (existingCharts.length > 0) {
            return;
          }
        } catch (error) {
          // Continue to generation if loading fails
        }
        
        // Use the default person if available, otherwise fall back to user data
        const chartPerson = defaultPerson || (user.birthData?.dateOfBirth && user.birthData?.timeOfBirth && user.birthData?.coordinates?.lat ? {
          name: user.username || '',
          birthData: user.birthData
        } : null);
        
        if (chartPerson?.birthData) {
          try {
            await generateChartRef.current({
              name: chartPerson.name || '',
              dateOfBirth: chartPerson.birthData.dateOfBirth,
              timeOfBirth: chartPerson.birthData.timeOfBirth,
              locationOfBirth: chartPerson.birthData.locationOfBirth || 'Unknown',
              coordinates: chartPerson.birthData.coordinates
            });
            
            // Track chart generation with essential metadata
            trackChartGeneration('natal', {
              isAutoGenerated: true,
              hasCompleteProfile: !!(user.birthData?.dateOfBirth && user.birthData?.timeOfBirth && user.birthData?.coordinates?.lat)
            });
          } catch (error) {
            // Error generating chart
          }
        }
      };
      
      loadOrGenerateChart();
    }, 1000); // Wait 1 second to let cache loading complete
    
    return () => clearTimeout(timeoutId);
  }, [cachedChart, isGenerating, user?.id, user?.birthData?.dateOfBirth, user?.birthData?.timeOfBirth, user?.birthData?.coordinates?.lat, defaultPerson]);
  
  // Handle share token from URL
  useEffect(() => {
    const shareToken = searchParams.get('shareToken');
    if (shareToken && !sharedChartLoaded) {
      const loadSharedChart = async () => {
        try {
          const response = await fetch(`/api/charts/shared?shareToken=${shareToken}`);
          const result = await response.json();
          
          if (result.success && result.chart) {
            const sharedChart = result.chart;
            // Convert shared chart to person format
            const sharedPerson: Person = {
              id: `shared_${shareToken}`,
              userId: 'shared',
              name: sharedChart.subjectName || 'Shared Chart',
              relationship: 'other',
              birthData: {
                dateOfBirth: sharedChart.dateOfBirth,
                timeOfBirth: sharedChart.timeOfBirth,
                locationOfBirth: sharedChart.locationOfBirth,
                coordinates: {
                  lat: sharedChart.latitude?.toString() || '',
                  lon: sharedChart.longitude?.toString() || '',
                },
              },
              createdAt: new Date(sharedChart.createdAt),
              updatedAt: new Date(sharedChart.createdAt),
              notes: `Shared chart from ${new Date(sharedChart.createdAt).toLocaleDateString()}`,
            };
            
            // Set as selected person
            setSelectedPerson(sharedPerson);
            setGlobalSelectedPerson(sharedPerson.id);
            setSharedChartLoaded(true);
            
            // Show success message
            showSuccess('Shared Chart Loaded', `Now viewing ${sharedPerson.name}'s chart`, 4000);
            
            // Clean up URL by removing the share token
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete('shareToken');
            router.replace(newUrl.pathname + newUrl.search);
          } else {
            showError('Share Link Invalid', 'This chart link is invalid or no longer available.', 5000);
          }
        } catch (error) {
          console.error('Error loading shared chart:', error);
          showError('Share Link Failed', 'Failed to load shared chart. Please try again.', 5000);
        }
      };
      
      loadSharedChart();
    }
  }, [searchParams, sharedChartLoaded, router, showSuccess, showError, setGlobalSelectedPerson]);

  // Track page view analytics
  useEffect(() => {
    // Page view tracking handled by Google Analytics automatically
  }, []);
  
  // Handler functions
  const handleClearAllCaches = async () => {
    if (!user) return;
    
    try {
      await handleRegenerateChart();
      showSuccess('Chart Regenerated', 'Your natal chart has been successfully regenerated with fresh calculations.', 4000);
    } catch (error) {
      showError('Regeneration Failed', 'Failed to regenerate your chart. Please try again.', 5000);
    }
  };
  
  const handleRegenerateChart = async () => {
    const personToUse = activeSelectedPerson;
    
    if (!personToUse?.birthData) {
      alert("No birth data available. Please select a person or add your birth data.");
      return;
    }
    
    try {
      const chartData = await generateChart(
        {
          name: personToUse.name || "",
          dateOfBirth: personToUse.birthData.dateOfBirth,
          timeOfBirth: personToUse.birthData.timeOfBirth,
          locationOfBirth: personToUse.birthData.locationOfBirth,
          coordinates: personToUse.birthData.coordinates,
        },
        true // forceRegenerate
      );
      
      trackChartGeneration('natal', {
        isRegeneration: true,
        personName: personToUse.name
      });
      
      if (chartData) {
        // Chart regenerated successfully
      }
    } catch (error) {
      alert("Failed to regenerate chart. Please try again.");
    }
  };
  
  const handlePersonChange = async (person: Person | null) => {
    setSelectedPerson(person);
    setGlobalSelectedPerson(person?.id || null);
    
    if (person?.birthData && user && !cachedChart) {
      try {
        await generateChart({
          name: person.name || "",
          dateOfBirth: person.birthData.dateOfBirth,
          timeOfBirth: person.birthData.timeOfBirth,
          locationOfBirth: person.birthData.locationOfBirth,
          coordinates: person.birthData.coordinates,
        });
      } catch (error) {
        // Error generating chart for selected person
      }
    }
  };
  
  const handleAddPersonClick = () => {
    // This is now handled by ChartQuickActions component
  };
  
  const handleShare = async () => {
    if (cachedChart?.id) {
      const shareUrl = await shareChart(cachedChart.id);
      if (shareUrl) {
        if (navigator.share) {
          try {
            await navigator.share({
              title: `${cachedChart.metadata?.name || 'My'} Natal Chart`,
              text: `Check out ${cachedChart.metadata?.name || 'my'} natal chart from ${BRAND.name}!`,
              url: shareUrl,
            });
          } catch {
            // User cancelled sharing or sharing failed, copy to clipboard
            try {
              await navigator.clipboard.writeText(shareUrl);
              showSuccess('Link Copied', 'Chart share link copied to clipboard.', 3000);
            } catch (clipboardError) {
              // Fallback: try to focus the document and retry
              try {
                window.focus();
                await navigator.clipboard.writeText(shareUrl);
                showSuccess('Link Copied', 'Chart share link copied to clipboard.', 3000);
              } catch (retryError) {
                // Final fallback: show the URL to user
                showSuccess('Share Link Ready', `Copy this link: ${shareUrl}`, 5000);
              }
            }
          }
        } else {
          // Fallback to clipboard
          try {
            await navigator.clipboard.writeText(shareUrl);
            showSuccess('Link Copied', 'Chart share link copied to clipboard.', 3000);
          } catch (clipboardError) {
            // Fallback: try to focus the document and retry
            try {
              window.focus();
              await navigator.clipboard.writeText(shareUrl);
              showSuccess('Link Copied', 'Chart share link copied to clipboard.', 3000);
            } catch (retryError) {
              // Final fallback: show the URL to user
              showSuccess('Share Link Ready', `Copy this link: ${shareUrl}`, 5000);
            }
          }
        }
      }
    }
  };
  
  // Computed values for UI
  const isLoading = isUserLoading || (isLoadingCache && hasExistingChart) || isGenerating || !user;
  
  // Use the activeSelectedPerson which properly includes the default person with relationship: 'self'
  const personToShow = activeSelectedPerson;
  
  const birthDataToShow = cachedChart?.metadata?.birthData || personToShow?.birthData;
  
  const loadingTitle = isUserLoading ? 'Loading Your Profile' :
    isGenerating ? 'Generating Your Chart' :
    'Loading Your Chart';
  
  const loadingDescription = isUserLoading ? 'Retrieving your birth data and preferences...' :
    isGenerating ? 'Creating your cosmic blueprint from the stars...' :
    'We\'re retrieving your cosmic blueprint. This should only take a moment...';
  
  return {
    // State
    router,
    user,
    selectedPerson,
    activeSelectedPerson,
    activeTab,
    cachedChart,
    personToShow,
    birthDataToShow,
    statusToast,
    
    // Loading states
    isLoading,
    isGenerating,
    loadingTitle,
    loadingDescription,
    
    // Handlers
    handleClearAllCaches,
    handleRegenerateChart,
    handlePersonChange,
    handleAddPersonClick,
    handleShare,
    hideStatus,
    setActiveTab,
  };
};