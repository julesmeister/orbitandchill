<!DOCTYPE html>
<html>
<head>
    <title>Chart Page Debug Tool</title>
    <style>
        body { font-family: monospace; margin: 0; display: flex; min-height: 100vh; }
        .left-panel { width: 50%; padding: 20px; overflow-y: auto; border-right: 2px solid #007acc; }
        .right-panel { width: 50%; padding: 20px; overflow-y: auto; background: #f8f9fa; }
        .button { padding: 10px; margin: 5px; background: #007acc; color: white; border: none; cursor: pointer; border-radius: 3px; }
        .button:hover { background: #0056b3; }
        .clear-button { background: #dc3545; }
        .clear-button:hover { background: #c82333; }
        .result { background: #f5f5f5; padding: 10px; margin: 10px 0; border-left: 4px solid #007acc; border-radius: 3px; }
        .error { border-left-color: #dc3545; background: #f8d7da; }
        .success { border-left-color: #28a745; background: #d4edda; }
        .warning { border-left-color: #ffc107; background: #fff3cd; }
        .form-section { margin: 20px 0; padding: 15px; background: #e8f4fd; border: 1px solid #bee5eb; border-radius: 5px; }
        .user-section { margin: 20px 0; padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px; }
        .chart-section { margin: 20px 0; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; }
        .db-section { margin: 20px 0; padding: 15px; background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 5px; }
        input[type="text"], input[type="date"], input[type="time"], select { 
            width: 250px; padding: 8px; margin: 5px; border: 1px solid #ccc; border-radius: 3px; 
        }
        .results-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #007acc; }
        .results-title { font-size: 18px; font-weight: bold; color: #007acc; }
        pre { white-space: pre-wrap; word-wrap: break-word; max-width: 100%; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="left-panel">
        <h1>ğŸ“Š Chart Page Debug Tool v1.0</h1>
        <div style="background: #4caf50; color: white; padding: 15px; margin: 10px 0; border-radius: 5px; font-weight: bold; text-align: center; font-size: 16px;">
            âœ… BIRTH DATA & CHART DEBUG TOOL LOADED
        </div>
        <div style="background: #ffeb3b; padding: 10px; margin: 10px 0; border-radius: 5px; color: #333;">
            <strong>ğŸ¯ Purpose:</strong> Debug birth data persistence issues with NatalChartForm and chart page fetching
        </div>
        
        <div class="user-section">
            <h3>ğŸ‘¤ User Store & Birth Data Debug</h3>
            <p style="font-size: 14px; color: #666; margin-bottom: 10px;">
                Test user store, database persistence, and birth data flow
            </p>
            <input type="text" id="userIdInput" placeholder="Enter User ID" style="width: 300px;" value="113425479876942125321">
            <button class="button" onclick="debugUserStore()">ğŸ—„ï¸ Debug User Store</button>
            <button class="button" onclick="testBirthDataPersistence()">ğŸ’¾ Test Birth Data Save</button>
            <button class="button" onclick="debugBirthDataFlow()">ğŸ”„ Debug Data Flow</button>
        </div>
        
        <div class="form-section">
            <h3>ğŸ“ NatalChartForm Simulation</h3>
            <p style="font-size: 14px; color: #666; margin-bottom: 10px;">
                Simulate form input and test auto-save functionality
            </p>
            <div style="margin-bottom: 15px;">
                <h4>Test Birth Data:</h4>
                <input type="text" id="testName" placeholder="Name" value="Test User">
                <input type="date" id="testDate" value="1990-06-15">
                <input type="time" id="testTime" value="14:30">
                <input type="text" id="testLocation" placeholder="Location" value="New York, NY, USA">
                <input type="text" id="testLat" placeholder="Latitude" value="40.7128">
                <input type="text" id="testLon" placeholder="Longitude" value="-74.0060">
            </div>
            <button class="button" onclick="simulateFormInput()">ğŸ“ Simulate Form Input</button>
            <button class="button" onclick="testAutoSave()">ğŸ’¾ Test Auto-Save</button>
            <button class="button" onclick="verifyFormPersistence()">âœ… Verify Persistence</button>
        </div>

        <div class="chart-section">
            <h3>ğŸ“Š Chart Generation & Caching Debug</h3>
            <p style="font-size: 14px; color: #666; margin-bottom: 10px;">
                Test chart generation, caching, and retrieval
            </p>
            <button class="button" onclick="testChartGeneration()">ğŸ¨ Test Chart Generation</button>
            <button class="button" onclick="debugChartCache()">ğŸ—‚ï¸ Debug Chart Cache</button>
            <button class="button" onclick="testChartPageData()">ğŸ“„ Test Chart Page Data</button>
            <button class="button" onclick="clearChartCache()">ğŸ—‘ï¸ Clear Chart Cache</button>
        </div>

        <div class="chart-section" style="background: #e8f5e8; border-color: #28a745;">
            <h3>ğŸ”— Chart Sharing Debug</h3>
            <p style="font-size: 14px; color: #666; margin-bottom: 10px;">
                Test chart sharing functionality and shared charts dropdown
            </p>
            <input type="text" id="chartIdInput" placeholder="Chart ID (optional)" style="width: 200px;">
            <input type="text" id="shareTokenInput" placeholder="Share Token (optional)" style="width: 200px;">
            <br>
            <button class="button" onclick="createTestSharedChart()">â• Create Test Shared Chart</button>
            <button class="button" onclick="testChartSharing()">ğŸ”— Test Chart Sharing</button>
            <button class="button" onclick="testSharedChartAccess()">ğŸ‘€ Test Shared Chart Access</button>
            <button class="button" onclick="testSharedChartsDropdown()">ğŸ“‹ Test Shared Charts List</button>
            <button class="button" onclick="testShareUrlGeneration()">ğŸŒ Test Share URL Generation</button>
            <br><br>
            <button class="button" onclick="runSharingTestSequence()" style="background: #28a745; font-weight: bold;">ğŸš€ Run Complete Sharing Test</button>
            <button class="button" onclick="debugDatabaseState()" style="background: #6f42c1; color: white;">ğŸ” Debug Database State</button>
            <button class="button" onclick="testMinimalChart()" style="background: #e83e8c; color: white;">ğŸ§ª Test Minimal Chart</button>
            <button class="button" onclick="testDatabaseConnection()" style="background: #fd7e14; color: white;">ğŸ”Œ Test Database Connection</button>
        </div>

        <div class="db-section">
            <h3>ğŸ’¾ Database & Storage Debug</h3>
            <p style="font-size: 14px; color: #666; margin-bottom: 10px;">
                Test IndexedDB, Zustand store, and localStorage
            </p>
            <button class="button" onclick="testIndexedDB()">ğŸ—„ï¸ Test IndexedDB</button>
            <button class="button" onclick="testZustandStore()">ğŸ“¦ Test Zustand Store</button>
            <button class="button" onclick="testLocalStorage()">ğŸ’¿ Test localStorage</button>
            <button class="button" onclick="compareStorageLayers()">ğŸ” Compare Storage</button>
        </div>

        <div>
            <h3>ğŸ”§ Comprehensive Tests</h3>
            <button class="button" onclick="runFullDiagnostic()">ğŸ”¬ Full Diagnostic</button>
            <button class="button" onclick="testDataConsistency()">ğŸ¯ Data Consistency</button>
        </div>
    </div>

    <div class="right-panel">
        <div class="results-header">
            <div class="results-title">ğŸ“Š Debug Results</div>
            <button class="button clear-button" onclick="clearResults()">ğŸ—‘ï¸ Clear Results</button>
        </div>
        <div id="results"></div>
    </div>

    <script>
        // Initialize test data
        document.getElementById('testDate').value = new Date().toISOString().split('T')[0];

        function addResult(title, data, type = 'success') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `
                <h3>${title}</h3>
                <pre>${JSON.stringify(data, null, 2)}</pre>
            `;
            results.appendChild(div);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        async function debugUserStore() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Test user profile API
                const profileResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                const profileData = await profileResponse.json();
                
                addResult('ğŸ‘¤ User Store Debug', {
                    userId: userId,
                    profile: {
                        statusCode: profileResponse.status,
                        success: profileResponse.ok,
                        data: profileData,
                        hasBirthData: !!(profileData.user?.dateOfBirth || profileData.user?.birthData)
                    },
                    analysis: {
                        userExists: profileResponse.ok,
                        hasBirthData: !!(profileData.user?.dateOfBirth || profileData.user?.birthData?.dateOfBirth),
                        birthDataStructure: profileData.user?.birthData ? 'nested' : profileData.user?.dateOfBirth ? 'flat' : 'none'
                    }
                }, profileResponse.ok ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ User Store Debug Error', { error: error.message }, 'error');
            }
        }

        async function testBirthDataPersistence() {
            try {
                const userId = document.getElementById('userIdInput').value;
                const testBirthData = {
                    dateOfBirth: document.getElementById('testDate').value,
                    timeOfBirth: document.getElementById('testTime').value,
                    locationOfBirth: document.getElementById('testLocation').value,
                    coordinates: {
                        lat: document.getElementById('testLat').value,
                        lon: document.getElementById('testLon').value
                    }
                };

                // Test saving birth data
                const saveResponse = await fetch('/api/users/profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: userId,
                        username: document.getElementById('testName').value,
                        authProvider: 'anonymous',
                        ...testBirthData,
                        // Also try nested structure
                        birthData: testBirthData
                    })
                });
                
                const saveData = await saveResponse.json();
                
                // Test retrieving the data
                const getResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                const getData = await getResponse.json();
                
                addResult('ğŸ’¾ Birth Data Persistence Test', {
                    testData: testBirthData,
                    save: {
                        statusCode: saveResponse.status,
                        success: saveResponse.ok,
                        data: saveData
                    },
                    retrieve: {
                        statusCode: getResponse.status,
                        success: getResponse.ok,
                        data: getData
                    },
                    analysis: {
                        dataSaved: saveResponse.ok,
                        dataRetrieved: getResponse.ok,
                        birthDataPersisted: !!(getData.user?.birthData || getData.user?.dateOfBirth),
                        coordinatesPersisted: !!(getData.user?.coordinates || getData.user?.birthData?.coordinates)
                    }
                }, saveResponse.ok && getResponse.ok ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Birth Data Persistence Error', { error: error.message }, 'error');
            }
        }

        async function debugBirthDataFlow() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Step 1: Check current user data
                const currentResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                const currentData = await currentResponse.json();
                
                // Step 2: Test the updateBirthData flow (simulate form auto-save)
                const updateData = {
                    dateOfBirth: '1990-06-15',
                    timeOfBirth: '14:30',
                    locationOfBirth: 'Test Location Flow',
                    coordinates: { lat: '40.7128', lon: '-74.0060' }
                };
                
                const updateResponse = await fetch('/api/users/profile', {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: userId,
                        birthData: updateData
                    })
                });
                
                const updateResult = await updateResponse.json();
                
                // Step 3: Verify the update
                const verifyResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                const verifyData = await verifyResponse.json();
                
                addResult('ğŸ”„ Birth Data Flow Debug', {
                    current: {
                        success: currentResponse.ok,
                        birthData: currentData.user?.birthData,
                        flatData: {
                            dateOfBirth: currentData.user?.dateOfBirth,
                            timeOfBirth: currentData.user?.timeOfBirth,
                            locationOfBirth: currentData.user?.locationOfBirth
                        }
                    },
                    update: {
                        statusCode: updateResponse.status,
                        success: updateResponse.ok,
                        sentData: updateData,
                        response: updateResult
                    },
                    verify: {
                        success: verifyResponse.ok,
                        updatedBirthData: verifyData.user?.birthData,
                        updatedFlatData: {
                            dateOfBirth: verifyData.user?.dateOfBirth,
                            timeOfBirth: verifyData.user?.timeOfBirth,
                            locationOfBirth: verifyData.user?.locationOfBirth
                        }
                    },
                    analysis: {
                        flowWorking: updateResponse.ok && verifyResponse.ok,
                        dataStructureConsistent: !!(verifyData.user?.birthData),
                        autoSaveSimulated: true
                    }
                }, 'success');
            } catch (error) {
                addResult('âŒ Birth Data Flow Error', { error: error.message }, 'error');
            }
        }

        async function simulateFormInput() {
            try {
                // Simulate the exact flow that happens in NatalChartForm
                const formData = {
                    name: document.getElementById('testName').value,
                    dateOfBirth: document.getElementById('testDate').value,
                    timeOfBirth: document.getElementById('testTime').value,
                    locationOfBirth: document.getElementById('testLocation').value,
                    coordinates: {
                        lat: document.getElementById('testLat').value,
                        lon: document.getElementById('testLon').value
                    }
                };
                
                // This simulates the updateFormData -> updateBirthData flow
                const { name, ...birthData } = formData;
                
                // Test the API call that would be made by the store (using PATCH for updates)
                const response = await fetch('/api/users/profile', {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: document.getElementById('userIdInput').value,
                        birthData: birthData
                    })
                });
                
                const data = await response.json();
                
                addResult('ğŸ“ Form Input Simulation', {
                    formData: formData,
                    birthDataExtracted: birthData,
                    apiCall: {
                        statusCode: response.status,
                        success: response.ok,
                        response: data
                    },
                    analysis: {
                        formDataValid: Object.values(birthData).every(v => v !== ''),
                        coordinatesValid: birthData.coordinates.lat && birthData.coordinates.lon,
                        apiWorking: response.ok
                    }
                }, response.ok ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Form Simulation Error', { error: error.message }, 'error');
            }
        }

        async function testAutoSave() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Simulate multiple auto-save calls (like typing in form)
                const autoSaveSteps = [
                    { field: 'dateOfBirth', value: '1990-06-15' },
                    { field: 'timeOfBirth', value: '14:30' },
                    { field: 'locationOfBirth', value: 'Auto Save Test Location' },
                    { field: 'coordinates', value: { lat: '40.7128', lon: '-74.0060' } }
                ];
                
                const results = [];
                
                for (let i = 0; i < autoSaveSteps.length; i++) {
                    const step = autoSaveSteps[i];
                    const partialData = {};
                    
                    // Build cumulative data
                    for (let j = 0; j <= i; j++) {
                        partialData[autoSaveSteps[j].field] = autoSaveSteps[j].value;
                    }
                    
                    const response = await fetch('/api/users/profile', {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            userId: userId,
                            birthData: partialData
                        })
                    });
                    
                    const data = await response.json();
                    
                    results.push({
                        step: i + 1,
                        field: step.field,
                        partialData: partialData,
                        success: response.ok,
                        statusCode: response.status
                    });
                    
                    // Small delay to simulate real typing
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                addResult('ğŸ’¾ Auto-Save Test', {
                    totalSteps: autoSaveSteps.length,
                    results: results,
                    analysis: {
                        allStepsSuccessful: results.every(r => r.success),
                        failedSteps: results.filter(r => !r.success).length,
                        autoSaveWorking: results.every(r => r.success)
                    }
                }, results.every(r => r.success) ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Auto-Save Test Error', { error: error.message }, 'error');
            }
        }

        async function verifyFormPersistence() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Get current data
                const response = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                const data = await response.json();
                
                // Check what data structure we have
                const user = data.user;
                const birthDataNested = user?.birthData;
                const birthDataFlat = {
                    dateOfBirth: user?.dateOfBirth,
                    timeOfBirth: user?.timeOfBirth,
                    locationOfBirth: user?.locationOfBirth,
                    coordinates: user?.coordinates
                };
                
                addResult('âœ… Form Persistence Verification', {
                    userId: userId,
                    userExists: !!user,
                    dataStructures: {
                        nested: {
                            exists: !!birthDataNested,
                            data: birthDataNested,
                            complete: birthDataNested && 
                                     birthDataNested.dateOfBirth && 
                                     birthDataNested.timeOfBirth && 
                                     birthDataNested.locationOfBirth &&
                                     birthDataNested.coordinates?.lat &&
                                     birthDataNested.coordinates?.lon
                        },
                        flat: {
                            exists: !!(birthDataFlat.dateOfBirth || birthDataFlat.timeOfBirth),
                            data: birthDataFlat,
                            complete: birthDataFlat.dateOfBirth && 
                                     birthDataFlat.timeOfBirth && 
                                     birthDataFlat.locationOfBirth &&
                                     birthDataFlat.coordinates?.lat &&
                                     birthDataFlat.coordinates?.lon
                        }
                    },
                    analysis: {
                        hasAnyBirthData: !!(birthDataNested || birthDataFlat.dateOfBirth),
                        dataStructurePreferred: birthDataNested ? 'nested' : 'flat',
                        readyForChartGeneration: !!(
                            (birthDataNested && birthDataNested.dateOfBirth && birthDataNested.coordinates?.lat) ||
                            (birthDataFlat.dateOfBirth && birthDataFlat.coordinates?.lat)
                        )
                    }
                }, response.ok ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Persistence Verification Error', { error: error.message }, 'error');
            }
        }

        async function testChartGeneration() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // First check if user has birth data
                const userResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                const userData = await userResponse.json();
                
                if (!userResponse.ok) {
                    throw new Error('User not found');
                }
                
                const birthData = userData.user?.birthData || {
                    dateOfBirth: userData.user?.dateOfBirth,
                    timeOfBirth: userData.user?.timeOfBirth,
                    locationOfBirth: userData.user?.locationOfBirth,
                    coordinates: userData.user?.coordinates
                };
                
                // Test chart generation API
                const chartResponse = await fetch('/api/chart/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: userId,
                        birthData: birthData
                    })
                });
                
                const chartData = await chartResponse.json();
                
                addResult('ğŸ¨ Chart Generation Test', {
                    userId: userId,
                    birthData: birthData,
                    generation: {
                        statusCode: chartResponse.status,
                        success: chartResponse.ok,
                        data: chartData,
                        hasChartData: !!(chartData.chart || chartData.svg)
                    },
                    analysis: {
                        birthDataComplete: !!(birthData.dateOfBirth && birthData.timeOfBirth && birthData.coordinates?.lat),
                        chartGenerated: chartResponse.ok,
                        chartDataValid: !!(chartData.chart || chartData.svg)
                    }
                }, chartResponse.ok ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Chart Generation Error', { error: error.message }, 'error');
            }
        }

        async function debugChartCache() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Test cache endpoints
                const cacheResponse = await fetch(`/api/chart/cache?userId=${encodeURIComponent(userId)}`);
                const cacheData = await cacheResponse.json();
                
                addResult('ğŸ—‚ï¸ Chart Cache Debug', {
                    userId: userId,
                    cache: {
                        statusCode: cacheResponse.status,
                        success: cacheResponse.ok,
                        data: cacheData,
                        hasCachedChart: !!(cacheData.chart || cacheData.cached)
                    },
                    analysis: {
                        cacheWorking: cacheResponse.ok,
                        chartCached: !!(cacheData.chart || cacheData.cached),
                        cacheAge: cacheData.timestamp ? new Date() - new Date(cacheData.timestamp) : 'unknown'
                    }
                }, cacheResponse.ok ? 'success' : 'warning');
            } catch (error) {
                addResult('âŒ Chart Cache Error', { error: error.message }, 'error');
            }
        }

        async function testChartPageData() {
            try {
                // Simulate what happens when /chart page loads
                const userId = document.getElementById('userIdInput').value;
                
                // Test the full flow: user data -> chart generation -> page load
                const steps = {
                    userProfile: null,
                    chartGeneration: null,
                    chartData: null
                };
                
                // Step 1: Get user profile (what useUserStore does)
                const profileResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                steps.userProfile = {
                    success: profileResponse.ok,
                    statusCode: profileResponse.status,
                    data: profileResponse.ok ? await profileResponse.json() : null
                };
                
                if (steps.userProfile.success && steps.userProfile.data?.user) {
                    const user = steps.userProfile.data.user;
                    const birthData = user.birthData || {
                        dateOfBirth: user.dateOfBirth,
                        timeOfBirth: user.timeOfBirth,
                        locationOfBirth: user.locationOfBirth,
                        coordinates: user.coordinates
                    };
                    
                    // Step 2: Test chart generation (what useNatalChart does)
                    if (birthData.dateOfBirth && birthData.coordinates?.lat) {
                        const chartResponse = await fetch('/api/chart/generate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                userId: userId,
                                birthData: birthData
                            })
                        });
                        
                        steps.chartGeneration = {
                            success: chartResponse.ok,
                            statusCode: chartResponse.status,
                            data: chartResponse.ok ? await chartResponse.json() : null
                        };
                        
                        // Step 3: Get chart data for display
                        if (steps.chartGeneration.success) {
                            const chartDataResponse = await fetch(`/api/chart?userId=${encodeURIComponent(userId)}`);
                            steps.chartData = {
                                success: chartDataResponse.ok,
                                statusCode: chartDataResponse.status,
                                data: chartDataResponse.ok ? await chartDataResponse.json() : null
                            };
                        }
                    }
                }
                
                addResult('ğŸ“„ Chart Page Data Test', {
                    userId: userId,
                    steps: steps,
                    analysis: {
                        userDataAvailable: steps.userProfile.success,
                        birthDataComplete: !!(steps.userProfile.data?.user?.birthData?.dateOfBirth || steps.userProfile.data?.user?.dateOfBirth),
                        chartGenerationWorking: !!steps.chartGeneration?.success,
                        chartDataRetrievable: !!steps.chartData?.success,
                        fullFlowWorking: steps.userProfile.success && 
                                        (steps.chartGeneration?.success || false) && 
                                        (steps.chartData?.success || false)
                    }
                }, steps.userProfile.success ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Chart Page Data Error', { error: error.message }, 'error');
            }
        }

        async function clearChartCache() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                const response = await fetch(`/api/chart/cache?userId=${encodeURIComponent(userId)}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                addResult('ğŸ—‘ï¸ Clear Chart Cache', {
                    userId: userId,
                    statusCode: response.status,
                    success: response.ok,
                    data: data
                }, response.ok ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Clear Cache Error', { error: error.message }, 'error');
            }
        }

        async function testIndexedDB() {
            try {
                // Test if we can access IndexedDB APIs directly
                const dbTest = {
                    available: 'indexedDB' in window,
                    databases: null,
                    testWrite: null,
                    testRead: null
                };
                
                if (dbTest.available) {
                    // Try to open a test database
                    const testDB = indexedDB.open('test-debug-db', 1);
                    
                    testDB.onsuccess = function(event) {
                        const db = event.target.result;
                        dbTest.testWrite = { success: true, message: 'IndexedDB accessible' };
                        db.close();
                        indexedDB.deleteDatabase('test-debug-db');
                    };
                    
                    testDB.onerror = function(event) {
                        dbTest.testWrite = { success: false, error: event.target.error };
                    };
                }
                
                // Also test if we can call our app's database APIs
                const appDbResponse = await fetch('/api/debug/db-connection');
                const appDbData = await appDbResponse.json();
                
                addResult('ğŸ—„ï¸ IndexedDB Test', {
                    browser: dbTest,
                    appDatabase: {
                        statusCode: appDbResponse.status,
                        success: appDbResponse.ok,
                        data: appDbData
                    },
                    analysis: {
                        browserSupport: dbTest.available,
                        appDatabaseWorking: appDbResponse.ok
                    }
                }, dbTest.available && appDbResponse.ok ? 'success' : 'warning');
            } catch (error) {
                addResult('âŒ IndexedDB Test Error', { error: error.message }, 'error');
            }
        }

        async function testZustandStore() {
            try {
                // We can't directly access the Zustand store from here, 
                // but we can test the APIs that the store would use
                const userId = document.getElementById('userIdInput').value;
                
                // Test the APIs that Zustand store calls
                const tests = {
                    loadProfile: null,
                    updateBirthData: null,
                    persistence: null
                };
                
                // Test loadProfile equivalent
                const loadResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                tests.loadProfile = {
                    success: loadResponse.ok,
                    statusCode: loadResponse.status,
                    data: loadResponse.ok ? await loadResponse.json() : null
                };
                
                // Test updateBirthData equivalent
                const updateResponse = await fetch('/api/users/profile', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: userId,
                        birthData: {
                            dateOfBirth: '1990-06-15',
                            timeOfBirth: '14:30',
                            locationOfBirth: 'Zustand Test Location',
                            coordinates: { lat: '40.7128', lon: '-74.0060' }
                        }
                    })
                });
                tests.updateBirthData = {
                    success: updateResponse.ok,
                    statusCode: updateResponse.status,
                    data: updateResponse.ok ? await updateResponse.json() : null
                };
                
                addResult('ğŸ“¦ Zustand Store Test', {
                    userId: userId,
                    tests: tests,
                    analysis: {
                        loadWorking: tests.loadProfile.success,
                        updateWorking: tests.updateBirthData.success,
                        storeAPIsFunctional: tests.loadProfile.success && tests.updateBirthData.success
                    }
                }, tests.loadProfile.success && tests.updateBirthData.success ? 'success' : 'error');
            } catch (error) {
                addResult('âŒ Zustand Store Test Error', { error: error.message }, 'error');
            }
        }

        async function testLocalStorage() {
            try {
                const testKey = 'debug-test-storage';
                const testData = { timestamp: Date.now(), test: true };
                
                // Test localStorage
                localStorage.setItem(testKey, JSON.stringify(testData));
                const retrieved = JSON.parse(localStorage.getItem(testKey) || '{}');
                localStorage.removeItem(testKey);
                
                // Test sessionStorage
                sessionStorage.setItem(testKey, JSON.stringify(testData));
                const sessionRetrieved = JSON.parse(sessionStorage.getItem(testKey) || '{}');
                sessionStorage.removeItem(testKey);
                
                addResult('ğŸ’¿ localStorage Test', {
                    localStorage: {
                        available: 'localStorage' in window,
                        writeSuccess: !!retrieved.test,
                        dataMatch: retrieved.timestamp === testData.timestamp
                    },
                    sessionStorage: {
                        available: 'sessionStorage' in window,
                        writeSuccess: !!sessionRetrieved.test,
                        dataMatch: sessionRetrieved.timestamp === testData.timestamp
                    },
                    analysis: {
                        localStorageWorking: 'localStorage' in window && !!retrieved.test,
                        sessionStorageWorking: 'sessionStorage' in window && !!sessionRetrieved.test,
                        storageAvailable: 'localStorage' in window
                    }
                }, 'success');
            } catch (error) {
                addResult('âŒ localStorage Test Error', { error: error.message }, 'error');
            }
        }

        async function compareStorageLayers() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Check what's in each storage layer
                const comparison = {
                    api: null,
                    localStorage: null,
                    sessionStorage: null
                };
                
                // API layer
                const apiResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                comparison.api = {
                    available: apiResponse.ok,
                    data: apiResponse.ok ? await apiResponse.json() : null
                };
                
                // localStorage layer (check for user store persistence)
                const localStorageKeys = Object.keys(localStorage).filter(key => 
                    key.includes('user') || key.includes('natal') || key.includes('chart')
                );
                comparison.localStorage = {
                    available: 'localStorage' in window,
                    relevantKeys: localStorageKeys,
                    data: localStorageKeys.reduce((acc, key) => {
                        try {
                            acc[key] = JSON.parse(localStorage.getItem(key) || '{}');
                        } catch {
                            acc[key] = localStorage.getItem(key);
                        }
                        return acc;
                    }, {})
                };
                
                // sessionStorage layer
                const sessionStorageKeys = Object.keys(sessionStorage).filter(key => 
                    key.includes('user') || key.includes('natal') || key.includes('chart')
                );
                comparison.sessionStorage = {
                    available: 'sessionStorage' in window,
                    relevantKeys: sessionStorageKeys,
                    data: sessionStorageKeys.reduce((acc, key) => {
                        try {
                            acc[key] = JSON.parse(sessionStorage.getItem(key) || '{}');
                        } catch {
                            acc[key] = sessionStorage.getItem(key);
                        }
                        return acc;
                    }, {})
                };
                
                addResult('ğŸ” Storage Layers Comparison', {
                    userId: userId,
                    comparison: comparison,
                    analysis: {
                        apiHasData: !!(comparison.api.data?.user),
                        localStorageHasData: localStorageKeys.length > 0,
                        sessionStorageHasData: sessionStorageKeys.length > 0,
                        dataConsistency: comparison.api.available ? 'check_api_vs_storage' : 'api_unavailable'
                    }
                }, comparison.api.available ? 'success' : 'warning');
            } catch (error) {
                addResult('âŒ Storage Comparison Error', { error: error.message }, 'error');
            }
        }

        async function runFullDiagnostic() {
            clearResults();
            addResult('ğŸ”¬ Starting Full Diagnostic...', { timestamp: new Date().toISOString() }, 'success');
            
            await debugUserStore();
            await testBirthDataPersistence();
            await debugBirthDataFlow();
            await testChartGeneration();
            await debugChartCache();
            await testChartPageData();
            await compareStorageLayers();
            
            // Add sharing tests
            addResult('ğŸ”— Starting Sharing Tests...', { timestamp: new Date().toISOString() }, 'success');
            await testChartSharing();
            await testSharedChartAccess();
            await testSharedChartsDropdown();
            await testShareUrlGeneration();
            
            addResult('âœ… Full Diagnostic Complete', { 
                timestamp: new Date().toISOString(),
                message: 'All tests completed including sharing functionality. Check results above for issues.'
            }, 'success');
        }

        async function testDataConsistency() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Get data from all sources and compare
                const sources = {
                    userProfile: null,
                    directAPI: null,
                    localStorage: null
                };
                
                // User profile API
                const profileResponse = await fetch(`/api/users/profile?userId=${encodeURIComponent(userId)}`);
                if (profileResponse.ok) {
                    sources.userProfile = await profileResponse.json();
                }
                
                // Check localStorage for cached data
                const localKeys = Object.keys(localStorage).filter(key => key.includes('user') || key.includes('birth'));
                sources.localStorage = localKeys.reduce((acc, key) => {
                    try {
                        acc[key] = JSON.parse(localStorage.getItem(key) || '{}');
                    } catch {
                        acc[key] = localStorage.getItem(key);
                    }
                    return acc;
                }, {});
                
                // Compare birth data across sources
                const profileBirthData = sources.userProfile?.user?.birthData || {
                    dateOfBirth: sources.userProfile?.user?.dateOfBirth,
                    timeOfBirth: sources.userProfile?.user?.timeOfBirth,
                    locationOfBirth: sources.userProfile?.user?.locationOfBirth,
                    coordinates: sources.userProfile?.user?.coordinates
                };
                
                addResult('ğŸ¯ Data Consistency Test', {
                    userId: userId,
                    sources: sources,
                    birthDataComparison: {
                        profileAPI: profileBirthData,
                        localStorage: sources.localStorage
                    },
                    analysis: {
                        profileHasBirthData: !!(profileBirthData.dateOfBirth),
                        localStorageHasData: Object.keys(sources.localStorage).length > 0,
                        dataConsistent: 'manual_comparison_needed',
                        readyForChart: !!(profileBirthData.dateOfBirth && profileBirthData.coordinates?.lat)
                    }
                }, 'success');
            } catch (error) {
                addResult('âŒ Data Consistency Error', { error: error.message }, 'error');
            }
        }

        // ===== CHART SHARING DEBUG FUNCTIONS =====

        async function createTestSharedChart() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Create test chart data - API expects coordinates as strings in an object
                const testChartRequest = {
                    userId: userId,
                    subjectName: `Test Shared Chart ${Date.now()}`,
                    dateOfBirth: '1990-06-15',
                    timeOfBirth: '14:30',
                    locationOfBirth: 'New York, NY, USA',
                    coordinates: {
                        lat: '40.7128',
                        lon: '-74.0060'
                    },
                    chartType: 'natal',
                    title: 'Debug Test Chart',
                    description: 'Created by debug tool for sharing tests',
                    isPublic: true,  // Make it public for sharing
                    forceRegenerate: true  // Force new chart generation
                };
                
                // First, create the chart
                const createResponse = await fetch('/api/charts/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(testChartRequest)
                });
                
                let createData;
                try {
                    createData = await createResponse.json();
                } catch (parseError) {
                    const responseText = await createResponse.text();
                    createData = { 
                        error: 'Failed to parse response', 
                        responseText: responseText.substring(0, 500),
                        parseError: parseError.message 
                    };
                }
                
                // If chart creation successful, generate share token
                let shareResult = null;
                if (createResponse.ok && createData.chart?.id) {
                    const shareResponse = await fetch(`/api/charts/${createData.chart.id}/share`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: userId })
                    });
                    
                    shareResult = {
                        statusCode: shareResponse.status,
                        success: shareResponse.ok,
                        data: shareResponse.ok ? await shareResponse.json() : null
                    };
                    
                    // Store the chart ID and share token for other tests
                    if (shareResult.success && shareResult.data) {
                        document.getElementById('chartIdInput').value = createData.chart.id;
                        if (shareResult.data.shareToken) {
                            document.getElementById('shareTokenInput').value = shareResult.data.shareToken;
                        } else if (shareResult.data.shareUrl && shareResult.data.shareUrl.includes('/chart/shared/')) {
                            // Extract token from URL if shareToken not provided separately
                            const extractedToken = shareResult.data.shareUrl.split('/chart/shared/').pop();
                            document.getElementById('shareTokenInput').value = extractedToken;
                        }
                    }
                }
                
                addResult('â• Create Test Shared Chart', {
                    userId: userId,
                    chartCreation: {
                        statusCode: createResponse.status,
                        success: createResponse.ok,
                        data: createData,
                        chartId: createData.chart?.id
                    },
                    shareGeneration: shareResult,
                    testData: testChartRequest,
                    analysis: {
                        chartCreated: createResponse.ok,
                        shareTokenGenerated: shareResult?.success || false,
                        readyForTesting: createResponse.ok && (shareResult?.success || false)
                    }
                }, createResponse.ok ? 'success' : 'error');
                
            } catch (error) {
                addResult('âŒ Create Test Shared Chart Error', { error: error.message }, 'error');
            }
        }

        async function testChartSharing() {
            try {
                const userId = document.getElementById('userIdInput').value;
                let chartId = document.getElementById('chartIdInput').value;
                
                // If no chart ID provided, try to get user's charts first
                if (!chartId) {
                    const chartsResponse = await fetch(`/api/charts/user/${encodeURIComponent(userId)}`);
                    if (chartsResponse.ok) {
                        const chartsData = await chartsResponse.json();
                        if (chartsData.charts && chartsData.charts.length > 0) {
                            chartId = chartsData.charts[0].id;
                            addResult('ğŸ“Š Found User Chart', { chartId, totalCharts: chartsData.charts.length }, 'success');
                        }
                    }
                }
                
                if (!chartId) {
                    addResult('âŒ Chart Sharing Test', { error: 'No chart ID available. Generate a chart first.' }, 'error');
                    return;
                }
                
                // Test generating a share token
                const shareResponse = await fetch(`/api/charts/${chartId}/share`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: userId })
                });
                
                let shareData;
                let responseText = '';
                try {
                    responseText = await shareResponse.text();
                    shareData = JSON.parse(responseText);
                } catch (parseError) {
                    shareData = { 
                        error: 'Failed to parse response', 
                        responseText: responseText ? responseText.substring(0, 500) : 'No response',
                        parseError: parseError.message 
                    };
                }
                
                // If sharing was successful, test accessing the shared chart
                let sharedChartTest = null;
                if (shareResponse.ok && shareData.shareToken) {
                    const accessResponse = await fetch(`/api/charts/shared?shareToken=${shareData.shareToken}`);
                    sharedChartTest = {
                        statusCode: accessResponse.status,
                        success: accessResponse.ok,
                        data: accessResponse.ok ? await accessResponse.json() : null
                    };
                }
                
                addResult('ğŸ”— Chart Sharing Test', {
                    userId: userId,
                    chartId: chartId,
                    shareGeneration: {
                        statusCode: shareResponse.status,
                        success: shareResponse.ok,
                        data: shareData,
                        shareToken: shareData.shareToken,
                        shareUrl: shareData.shareUrl
                    },
                    sharedChartAccess: sharedChartTest,
                    analysis: {
                        shareTokenGenerated: !!(shareData.shareToken),
                        shareUrlCreated: !!(shareData.shareUrl),
                        sharedChartAccessible: sharedChartTest?.success || false,
                        fullSharingFlowWorking: shareResponse.ok && (sharedChartTest?.success || false)
                    }
                }, shareResponse.ok ? 'success' : 'error');
                
                // Store the share token for other tests (extract from URL if needed)
                if (shareData.shareToken) {
                    document.getElementById('shareTokenInput').value = shareData.shareToken;
                } else if (shareData.shareUrl && shareData.shareUrl.includes('/chart/shared/')) {
                    // Extract token from URL if shareToken not provided separately
                    const extractedToken = shareData.shareUrl.split('/chart/shared/').pop();
                    document.getElementById('shareTokenInput').value = extractedToken;
                }
                
            } catch (error) {
                addResult('âŒ Chart Sharing Test Error', { error: error.message }, 'error');
            }
        }

        async function testSharedChartAccess() {
            try {
                let shareToken = document.getElementById('shareTokenInput').value;
                
                if (!shareToken) {
                    addResult('âŒ Shared Chart Access Test', { error: 'No share token provided. Run Chart Sharing test first or enter a token.' }, 'error');
                    return;
                }
                
                // Extract token from URL if a full URL was provided
                if (shareToken.includes('/chart/shared/')) {
                    shareToken = shareToken.split('/chart/shared/').pop();
                }
                
                // Test accessing the shared chart
                const accessResponse = await fetch(`/api/charts/shared?shareToken=${shareToken}`);
                const accessData = accessResponse.ok ? await accessResponse.json() : null;
                
                // Test the shared chart page route
                const pageResponse = await fetch(`/chart/shared/${shareToken}`);
                const pageWorking = pageResponse.ok;
                
                addResult('ğŸ‘€ Shared Chart Access Test', {
                    shareToken: shareToken,
                    apiAccess: {
                        statusCode: accessResponse.status,
                        success: accessResponse.ok,
                        data: accessData,
                        hasChartData: !!(accessData?.chart),
                        chartInfo: accessData?.chart ? {
                            subjectName: accessData.chart.subjectName,
                            dateOfBirth: accessData.chart.dateOfBirth,
                            shareToken: accessData.chart.shareToken,
                            isPublic: accessData.chart.isPublic
                        } : null
                    },
                    pageAccess: {
                        statusCode: pageResponse.status,
                        success: pageResponse.ok,
                        sharePageWorking: pageWorking
                    },
                    analysis: {
                        tokenValid: accessResponse.ok,
                        chartDataComplete: !!(accessData?.chart?.chartData),
                        sharePageAccessible: pageWorking,
                        fullAccessWorking: accessResponse.ok && pageWorking
                    }
                }, accessResponse.ok ? 'success' : 'error');
                
            } catch (error) {
                addResult('âŒ Shared Chart Access Error', { error: error.message }, 'error');
            }
        }

        async function testSharedChartsDropdown() {
            try {
                // Test the shared charts list API (used by the dropdown)
                const listResponse = await fetch('/api/charts/shared?list=true');
                const listData = listResponse.ok ? await listResponse.json() : null;
                
                // Test the hook endpoint structure
                let hookTestResult = null;
                if (listData?.charts) {
                    hookTestResult = {
                        totalCharts: listData.charts.length,
                        sampleChart: listData.charts[0] || null,
                        chartStructure: listData.charts[0] ? Object.keys(listData.charts[0]) : [],
                        hasRequiredFields: listData.charts.length > 0 ? !!(
                            listData.charts[0].shareToken &&
                            listData.charts[0].subjectName &&
                            listData.charts[0].dateOfBirth &&
                            listData.charts[0].chartData
                        ) : false
                    };
                }
                
                addResult('ğŸ“‹ Shared Charts Dropdown Test', {
                    listAPI: {
                        statusCode: listResponse.status,
                        success: listResponse.ok,
                        data: listData,
                        chartsCount: listData?.charts?.length || 0
                    },
                    hookCompatibility: hookTestResult,
                    dropdownDataStructure: {
                        hasCharts: !!(listData?.charts?.length),
                        chartFieldsValid: hookTestResult?.hasRequiredFields || false,
                        sampleChartFields: hookTestResult?.chartStructure || []
                    },
                    analysis: {
                        apiWorking: listResponse.ok,
                        hasSharedCharts: !!(listData?.charts?.length),
                        chartsHaveRequiredData: hookTestResult?.hasRequiredFields || false,
                        dropdownReady: listResponse.ok && !!(listData?.charts?.length)
                    }
                }, listResponse.ok ? 'success' : 'warning');
                
            } catch (error) {
                addResult('âŒ Shared Charts Dropdown Error', { error: error.message }, 'error');
            }
        }

        async function testShareUrlGeneration() {
            try {
                const userId = document.getElementById('userIdInput').value;
                let chartId = document.getElementById('chartIdInput').value;
                
                // Get a chart ID if not provided
                if (!chartId) {
                    const chartsResponse = await fetch(`/api/charts/user/${encodeURIComponent(userId)}`);
                    if (chartsResponse.ok) {
                        const chartsData = await chartsResponse.json();
                        if (chartsData.charts && chartsData.charts.length > 0) {
                            chartId = chartsData.charts[0].id;
                        }
                    }
                }
                
                if (!chartId) {
                    addResult('âŒ Share URL Generation Test', { error: 'No chart available for URL generation' }, 'error');
                    return;
                }
                
                // Test the share endpoint
                const shareResponse = await fetch(`/api/charts/${chartId}/share`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: userId })
                });
                
                let shareData;
                let responseText = '';
                try {
                    responseText = await shareResponse.text();
                    shareData = JSON.parse(responseText);
                } catch (parseError) {
                    shareData = { 
                        error: 'Failed to parse response', 
                        responseText: responseText ? responseText.substring(0, 500) : 'No response',
                        parseError: parseError.message 
                    };
                }
                
                // Analyze the generated URL structure
                let urlAnalysis = null;
                if (shareData.shareUrl) {
                    const url = new URL(shareData.shareUrl);
                    urlAnalysis = {
                        fullUrl: shareData.shareUrl,
                        baseUrl: url.origin,
                        path: url.pathname,
                        expectedPattern: '/chart/shared/[token]',
                        pathMatches: url.pathname.includes('/chart/shared/'),
                        tokenInPath: url.pathname.split('/').pop(),
                        tokenMatches: url.pathname.split('/').pop() === shareData.shareToken
                    };
                }
                
                addResult('ğŸŒ Share URL Generation Test', {
                    chartId: chartId,
                    shareGeneration: {
                        statusCode: shareResponse.status,
                        success: shareResponse.ok,
                        shareToken: shareData.shareToken,
                        shareUrl: shareData.shareUrl
                    },
                    urlAnalysis: urlAnalysis,
                    analysis: {
                        urlGenerated: !!(shareData.shareUrl),
                        urlStructureValid: urlAnalysis?.pathMatches && urlAnalysis?.tokenMatches,
                        tokenEmbedded: urlAnalysis?.tokenMatches || false,
                        readyForSharing: shareResponse.ok && !!(shareData.shareUrl) && (urlAnalysis?.pathMatches || false)
                    }
                }, shareResponse.ok && urlAnalysis?.pathMatches ? 'success' : 'error');
                
            } catch (error) {
                addResult('âŒ Share URL Generation Error', { error: error.message }, 'error');
            }
        }

        async function testDatabaseConnection() {
            try {
                addResult('ğŸ”Œ Testing Database Connection...', { 
                    timestamp: new Date().toISOString()
                }, 'success');
                
                // Test basic database connection
                const dbResponse = await fetch('/api/debug/db-connection');
                let dbData;
                try {
                    dbData = await dbResponse.json();
                } catch (parseError) {
                    const responseText = await dbResponse.text();
                    dbData = { 
                        error: 'Failed to parse response',
                        responseText: responseText.substring(0, 500)
                    };
                }
                
                // Test table listing
                const tablesResponse = await fetch('/api/debug/list-tables');
                let tablesData;
                try {
                    tablesData = await tablesResponse.json();
                } catch (parseError) {
                    const responseText = await tablesResponse.text();
                    tablesData = { 
                        error: 'Failed to parse response',
                        responseText: responseText.substring(0, 500)
                    };
                }
                
                addResult('ğŸ”Œ Database Connection Results', {
                    basicConnection: {
                        statusCode: dbResponse.status,
                        success: dbResponse.ok,
                        data: dbData
                    },
                    tablesListing: {
                        statusCode: tablesResponse.status,
                        success: tablesResponse.ok,
                        data: tablesData
                    },
                    analysis: {
                        dbConnectionWorking: dbResponse.ok,
                        tablesAccessible: tablesResponse.ok,
                        hasNatalChartsTable: !!(tablesData?.tables?.includes?.('natal_charts')),
                        databaseFullyOperational: dbResponse.ok && tablesResponse.ok
                    }
                }, dbResponse.ok ? 'success' : 'error');
                
            } catch (error) {
                addResult('âŒ Database Connection Test Error', { error: error.message }, 'error');
            }
        }

        async function testMinimalChart() {
            try {
                const userId = document.getElementById('userIdInput').value;
                
                // Test with the most basic chart request possible
                const minimalRequest = {
                    userId: userId,
                    subjectName: 'Minimal Test Chart',
                    dateOfBirth: '1990-06-15',
                    timeOfBirth: '12:00',
                    locationOfBirth: 'London, UK',
                    coordinates: {
                        lat: '51.5074',
                        lon: '-0.1278'
                    }
                };
                
                addResult('ğŸ§ª Testing Minimal Chart Creation...', { 
                    timestamp: new Date().toISOString(),
                    request: minimalRequest
                }, 'success');
                
                const response = await fetch('/api/charts/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(minimalRequest)
                });
                
                let responseData;
                const responseText = await response.text();
                try {
                    responseData = JSON.parse(responseText);
                } catch (parseError) {
                    responseData = { 
                        error: 'Failed to parse response',
                        responseText: responseText.substring(0, 1000)
                    };
                }
                
                // Wait for potential database save
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Check if chart was actually saved
                const userChartsResponse = await fetch(`/api/charts/user/${encodeURIComponent(userId)}`);
                const userChartsData = userChartsResponse.ok ? await userChartsResponse.json() : null;
                
                addResult('ğŸ§ª Minimal Chart Test Results', {
                    creation: {
                        statusCode: response.status,
                        success: response.ok,
                        data: responseData,
                        chartId: responseData.chart?.id,
                        hasChartData: !!(responseData.chart?.chartData),
                        chartDataLength: responseData.chart?.chartData?.length || 0,
                        isTemporary: responseData.temporary || false
                    },
                    databaseCheck: {
                        statusCode: userChartsResponse.status,
                        success: userChartsResponse.ok,
                        chartsFound: userChartsData?.charts?.length || 0,
                        charts: userChartsData?.charts
                    },
                    analysis: {
                        apiWorking: response.ok,
                        chartGenerated: !!(responseData.chart?.id),
                        chartDataPresent: !!(responseData.chart?.chartData),
                        savedToDatabase: !!(userChartsData?.charts?.length > 0),
                        dbSaveWorking: response.ok && !!(userChartsData?.charts?.length > 0)
                    }
                }, response.ok ? 'success' : 'error');
                
                // Update form fields if chart was created
                if (responseData.chart?.id) {
                    document.getElementById('chartIdInput').value = responseData.chart.id;
                }
                
            } catch (error) {
                addResult('âŒ Minimal Chart Test Error', { error: error.message }, 'error');
            }
        }

        async function debugDatabaseState() {
            try {
                const userId = document.getElementById('userIdInput').value;
                const chartId = document.getElementById('chartIdInput').value;
                const shareToken = document.getElementById('shareTokenInput').value;
                
                addResult('ğŸ” Database State Debug', { 
                    timestamp: new Date().toISOString(),
                    inputs: { userId, chartId, shareToken }
                }, 'success');
                
                // Check user's charts
                const userChartsResponse = await fetch(`/api/charts/user/${encodeURIComponent(userId)}`);
                const userChartsData = userChartsResponse.ok ? await userChartsResponse.json() : null;
                
                // Check shared charts list
                const sharedChartsResponse = await fetch('/api/charts/shared?list=true');
                const sharedChartsData = sharedChartsResponse.ok ? await sharedChartsResponse.json() : null;
                
                // Check specific chart by ID (if available)
                let specificChartData = null;
                if (chartId) {
                    const specificChartResponse = await fetch(`/api/charts/${chartId}`);
                    specificChartData = specificChartResponse.ok ? await specificChartResponse.json() : null;
                }
                
                // Check chart by share token (if available)
                let tokenChartData = null;
                if (shareToken) {
                    const tokenChartResponse = await fetch(`/api/charts/shared?shareToken=${shareToken}`);
                    tokenChartData = tokenChartResponse.ok ? await tokenChartResponse.json() : { 
                        error: 'Failed',
                        status: tokenChartResponse.status 
                    };
                }
                
                addResult('ğŸ” Database State Results', {
                    userCharts: {
                        statusCode: userChartsResponse.status,
                        success: userChartsResponse.ok,
                        count: userChartsData?.charts?.length || 0,
                        data: userChartsData
                    },
                    sharedCharts: {
                        statusCode: sharedChartsResponse.status,
                        success: sharedChartsResponse.ok,
                        count: sharedChartsData?.charts?.length || 0,
                        data: sharedChartsData
                    },
                    specificChart: specificChartData ? {
                        found: true,
                        data: specificChartData
                    } : { found: false },
                    tokenChart: tokenChartData,
                    analysis: {
                        userHasCharts: !!(userChartsData?.charts?.length),
                        hasSharedCharts: !!(sharedChartsData?.charts?.length),
                        tokenWorking: !!(tokenChartData && !tokenChartData.error),
                        databaseConsistency: 'check_data_above'
                    }
                }, userChartsResponse.ok ? 'success' : 'error');
                
            } catch (error) {
                addResult('âŒ Database State Debug Error', { error: error.message }, 'error');
            }
        }

        async function runSharingTestSequence() {
            try {
                addResult('ğŸš€ Starting Complete Sharing Test Sequence...', { 
                    timestamp: new Date().toISOString(),
                    note: 'This will create a test chart, share it, and test all sharing functionality'
                }, 'success');
                
                // Step 1: Create test shared chart
                await createTestSharedChart();
                
                // Wait a moment for database to update
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Step 2: Test chart sharing (if chart was created)
                await testChartSharing();
                
                // Step 3: Test shared chart access
                await testSharedChartAccess();
                
                // Step 4: Test shared charts dropdown (should now have at least 1 chart)
                await testSharedChartsDropdown();
                
                // Step 5: Test share URL generation
                await testShareUrlGeneration();
                
                addResult('âœ… Complete Sharing Test Sequence Finished', { 
                    timestamp: new Date().toISOString(),
                    message: 'All sharing tests completed. Check results above for any issues.'
                }, 'success');
                
            } catch (error) {
                addResult('âŒ Sharing Test Sequence Error', { error: error.message }, 'error');
            }
        }

        console.log('ğŸ”§ Chart Debug Tool loaded with sharing functionality. Use buttons to test birth data persistence, chart generation, and sharing features.');
    </script>
</body>
</html>